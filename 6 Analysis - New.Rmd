---
title: "R IMC Pipeline"
output: html_document
date: "2024-05-16"
authors: oscardong4@gmail.com and heeva.baharlou@gmail.com
---

# R IMC Pipeline

```{r setup, include=FALSE}
source("https://raw.githubusercontent.com/CVR-MucosalImmunology/IMC/main/.assets/functions.R")
if (!require("knitr", quietly = TRUE)) {install.packages(p)}
knitr::opts_knit$set(root.dir = "C:/Users/daniel.buffa/ImcSegmentationPipeline/IMC/analysis")
```

## Install Packages

```{r eval = FALSE, echo = FALSE, include = False}
norm_pack = c("tidyverse", "BiocManager", "viridis", "RColorBrewer", "cowplot", "gridExtra", "tiff", "kohonen")
for (p in norm_pack) {
  if (!require(p, quietly = TRUE)) {
    install.packages(p)
  }
}

bioc_pack = c("SpatialExperiment", "dittoSeq", "flowCore", "scater", "BiocSingular", "bluster", "ConsensusClusterPlus", "CATALYST")
for (p in bioc_pack) {
  if (!require(p, quietly = TRUE)) {
    BiocManager::install(p)
  }
}
```

## Load in Packages

```{r eval = FALSE, echo = FALSE, include = False}
library(tidyverse)
library(SpatialExperiment)
library(dittoSeq)
library(viridis)
library(RColorBrewer)
library(flowCore)
library(scater)
library(cowplot)
library(BiocSingular)
library(bluster)
library(ConsensusClusterPlus)
library(gridExtra)
library(tiff)
```

## 1a) Create Dataframe from CellProfiler Output

Before this step, make sure to modify `Image.csv` as necessary.

```{r}
cells = read.csv("5_cellprofiler_output/cell.csv")
panel = read.csv("../raw/panel.csv")
image = read.csv("5_cellprofiler_output/Image.csv")

image = image %>%
  mutate(Image = str_remove(FileName_FullStack , "_full\\.tiff")) %>%
  select(-FileName_FullStack)

panel = panel %>%
  dplyr::filter(trimws(Target) != "") %>%
  mutate(Metal = Metal.Tag) %>% 
  select("Metal", "Target") %>%
  dplyr::filter(Metal != "Ir191")

cellsCombined = left_join(cells, image, by = join_by(ImageNumber))

rename_vec = c(
  "Image" = "Image",
  "ImageNumber" = "ImageID",
  "ObjectNumber" = "CellID",
  "AreaShape_Area" = "Area",
  "AreaShape_Center_X" = "X",
  "AreaShape_Center_Y" = "Y",
  "DonorID" = "DonorID",
  "Condition" = "Condition"
)

# Change names in cellsCombined from old names to new names
names(cellsCombined) = ifelse(names(cellsCombined) %in% names(rename_vec), rename_vec[names(cellsCombined)], names(cellsCombined))

# Name marker columns
markers = panel[,"Target"]
ordered_markers = markers[createSortedVector(length(markers))]
colnames(cellsCombined)[6:(length(markers)+5)] = ordered_markers

# Keep only desired columns
meta = unname(sapply(strsplit(rename_vec, " = "), '[', 1))
keep = c(meta,ordered_markers)
cellsCombined = cellsCombined %>% select(all_of(keep))

dir.create("RDSFiles", showWarnings = FALSE)
saveRDS(cellsCombined, "RDSFiles/IMCData.rds")
```

## 1b) Creating SpatialExperiment ('spe') Object

```{r}
# Marker expression, other cellular features and spatial features (co-ordinates) are read and merged into a spatial experiment object
dt = readRDS("RDSFiles/IMCData.rds")

# Split data into marker intensities, metadata and co-ordinates
counts = dt[, ordered_markers]*65535
metadata = dt[, setdiff(meta, c("X","Y"))]
coords = dt[, c("X","Y")]

# Create spatial object
spe = SpatialExperiment(
  assays = list(counts = t(counts)),
  colData = metadata,
  spatialCoords = as.matrix(coords),
  sample_id = as.character(metadata$ImageID)
)

# Change variables to 'factor' type
spe$Image = as.factor(spe$Image)
spe$ImageID = as.factor(spe$ImageID)
spe$DonorID = as.factor(spe$DonorID)

### Assigning colour palettes
color_vectors <- list()

# DonorID
donor_ids <- unique(spe$DonorID)
# Create a color vector that repeats  if there are more than 12 unique DonorIDs
donor_colors <- brewer.pal(12, name = "Paired")[as.numeric(donor_ids) %% 12 + 1]
# Set the names of the colors to match the unique DonorIDs
DonorID <- setNames(donor_colors, donor_ids)
color_vectors$DonorID <- DonorID

# ImageID
image_ids <- unique(spe$ImageID)
# Create a color vector that repeats  if there are more than 12 unique ImageIDs
image_colors <- brewer.pal(12, name = "Paired")[as.numeric(image_ids) %% 12 + 1]
# Set the names of the colors to match the unique ImageIDs
ImageID <- setNames(image_colors, image_ids)
color_vectors$ImageID <- ImageID

metadata(spe)$color_vectors <- color_vectors

colnames(spe) = paste0(spe$ImageID, "_", spe$CellID)

# Plot current distribution
dittoRidgePlot(spe, var="CD3", group.by="ImageID", assay="counts", max=10) +
    ggtitle("CD3 - before transformation")

# Plot distribution after arcsinh transforming data
assay(spe, "exprs") = asinh(counts(spe))
dittoRidgePlot(spe, var="CD3", group.by="ImageID", assay="exprs", max=10) +
    ggtitle("CD3 - after arcsinh transformation")

### Standardise values between 0 and 1 for each image
# Extract the expression matrix and image information
exprs_matrix = assay(spe, "exprs")
images = spe$Image

# Get unique images and channels
unique_images = unique(images)
channels = rownames(exprs_matrix)

# Prepare a matrix to store standardised expressions
base_matrix = matrix(NA, nrow = nrow(exprs_matrix), ncol = ncol(exprs_matrix))
rownames(base_matrix) = channels
colnames(base_matrix) = colnames(exprs_matrix)

# Iterate over each image and channel to standardise
for (image in unique_images) {
    image_indices = which(images == image)
    for (channel in channels) {
        channel_data = exprs_matrix[channel, image_indices]
        # Apply min-max scaling
        min_val = min(channel_data, na.rm = TRUE)
        max_val = max(channel_data, na.rm = TRUE)
        range_val = max_val - min_val
        # Avoid division by zero if all values in channel_data are the same
        if (range_val != 0) {
            norm_data = (channel_data - min_val) / range_val
        } else {
            norm_data = rep(0, length(channel_data))  
        }
        base_matrix[channel, image_indices] <- norm_data
    }
}

# Assign the standardised data back to the assay
assay(spe, "norm_exprs") = base_matrix

# Plot distribution after standardising the data
dittoRidgePlot(spe, var="CD3", group.by="ImageID", assay="norm_exprs", max=1.0) + ggtitle("CD3 - after standardising")

# Add a universal CellID column
colData(spe)$uCellID = 1:length(spe$CellID) 
uIDKey = as.data.frame(colData(spe))
uIDKey = uIDKey %>%
  group_by(Image) %>%
  dplyr::filter(row_number()==1) %>%
  select(Image, ImageID, uCellID)

# Write a csv matching ImageIDs with uCellIDs
write.csv(uIDKey, "Image_uCellID_key.csv")
saveRDS(spe, "RDSFiles/spe.rds")
```

## 2a) Export as '.fcs' to gate in FlowJo

```{r}
spe = readRDS("RDSFiles/spe.rds")
image = read.csv("5_cellprofiler_output/image.csv") %>%
  mutate(ImageName = str_remove(FileName_FullStack , "_full\\.tiff")) %>%  
  select(ImageNumber, ImageName) %>%
  dplyr::rename(ImageID = ImageNumber)

metadata = as.data.frame(colData(spe)) %>%
  select(ImageID, uCellID, CellID, Area)

# Multiply by 1000 to match scale of visualisation in flowjo.
assayData = as.data.frame(t(assay(spe, "norm_exprs")))*1000

# Combine metadata and assay data
df = cbind(metadata, as.data.frame(spatialCoords(spe)), assayData)
df$ImageID = as.numeric(df$ImageID)
df = df %>%
  left_join(image, by="ImageID") %>%
  group_by(ImageID) %>%
  mutate(Y = max(Y)-Y)

split_data = split(df, df$ImageName)
dir.create("../FlowJo/exports", showWarnings = FALSE, recursive = TRUE)
lapply(names(split_data), function(name) write_fcs(split_data[[name]], name))
```

## 2b) Prepare 'MantisProject' folder to view in Mantis

```{r}
spe = readRDS("RDSFiles/spe.rds")
panel = read.csv("../raw/panel.csv")
dir.create("../MantisProject", showWarnings = FALSE)
tiffs = list.files("1c_full_images", pattern = "\\.tiff$")
csvs = list.files("1c_full_images", pattern = "\\.csv$")

# Generate individual channel images as TIFFs and copy them to Mantis folder
for (x in seq_along(tiffs)) {
  cur_img = gsub(".{10}$", "", tiffs[x])
  dir.create(paste0("../MantisProject/", cur_img), showWarnings = FALSE)
  cur_tiff = readTIFF(paste0("1c_full_images/", tiffs[x]), all=TRUE)
  cur_csv = read.csv(paste0("1c_full_images/", csvs[x]), header=FALSE)$V1
  for (channel in seq_along(cur_tiff)) {
    metal_tag = cur_csv[channel]
    marker = panel$Target[panel$Metal.Tag == metal_tag]
    filename = paste0("../MantisProject/", cur_img, "/", marker, ".tiff")
    mat = cur_tiff[[channel]]*65535
    writeTIFF((mat-min(mat))/(max(mat)-min(mat)), filename)
  }
}

# Copy segmentation masks to Mantis folder
seg_list = list.files("3a_segmentation_masks", pattern = "\\.tif$")
for (cur_dir in seg_list) {
  cur_img = gsub(".{23}$", "", cur_dir)
  new_dir = paste0("../MantisProject/", cur_img, "/SegmentationFile.tif")
  file.copy(paste0("3a_segmentation_masks/", cur_dir), new_dir)
}

# Extract the full assay data (markers) and transpose it
markers = rownames(spe)
marker_data = as.data.frame(t(assay(spe, "norm_exprs")))
# Add metadata as columns to marker_data
metadata = as.data.frame(colData(spe))
marker_data = cbind(metadata, marker_data)

for (img in unique(colData(spe)$Image)) {
  # Filter the combined data to keep only rows corresponding to images in Mantis
  filtered_data = marker_data[marker_data$Image %in% c(img), ]
  # Select only relevant columns
  selected_columns = c("Image", "CellID", markers)
  final_data = filtered_data[, selected_columns]
  # Check if all entries in the 'Image' column are the same (only one image)
  if (length(unique(final_data$Image)) == 1) {
      final_data$Image <- NULL
  }
  # Rename the remaining columns if necessary
  colnames(final_data)[colnames(final_data) %in% c("CellID")] = c("Segment ID")
  # Save the final filtered and selected data to a CSV file
  write.csv(final_data, paste0("../MantisProject/", img, "/SegmentFeatures.csv"), row.names = FALSE)
}
```

## 2c) Gate in FlowJo with reference to Mantis

## 3. Import FlowJo clusters into Mantis for viewing

You can create new gates in FlowJo then re-export for viewing again if desired by re-running this step.

**Note:** each cell can only be assigned to ONE population

```{r}
spe = readRDS("RDSFiles/spe.rds")

csvs = list.files(path = "../FlowJo/exports", pattern = "*.csv", full.names = TRUE)
add_celltype = function(x) {
  df = read.csv(x, header = T)
  celltype = sub("\\.csv$", "", basename(x))
  df$celltype_flowjo = rep(celltype, nrow(df))
  return(df)
}

csvs = lapply(csvs, add_celltype)
flowjo_df = bind_rows(csvs) %>%
  select(uCellID, celltype_flowjo)
flowjo_df$celltype_flowjo = as.factor(flowjo_df$celltype_flowjo)

metadata = as.data.frame(colData(spe))
flowjo_df = left_join(metadata, flowjo_df, by = c("uCellID"))

celltype_info = flowjo_df[, c("Image", "CellID", "celltype_flowjo")] %>%
  na.omit()

celltype_by_image = split(celltype_info, celltype_info$Image)

extract_celltypes = function(img) {
  df = celltype_by_image[[img]]
  return(as.data.frame(df))
}

celltypes = lapply(names(celltype_by_image), extract_celltypes)
celltype_df = bind_rows(celltypes)

write.table(celltype_df, "../MantisProject/FlowJo_CellTypes.csv", sep=",",  col.names=FALSE, row.names=FALSE)
saveRDS(celltype_df, "RDSFiles/flowjo_celltypes.rds")
```

## 4a) SOM clustering

```{r}
celltype_df = readRDS("RDSFiles/flowjo_celltypes.rds")
spe = readRDS("RDSFiles/spe.rds")
colData(spe)$to_cluster = NULL

# List of populations to perform clustering on
to_cluster = c("CD3+", "Test", "Hello")
maxClust = 30
clustNumber = 12
forClust = c("CD45RO", "CD8", "CXCR3", 
             "CCR7", "CCR6", "Ki67",
             "CD69-Cy5", "CD3", "CD4", "HLA-DR")

cells_forClust = celltype_df[celltype_df$celltype_flowjo %in% to_cluster, ] %>%
  select(-celltype_flowjo) %>%
  distinct()
cells_forClust$to_cluster = "Y"

metadata = as.data.frame(colData(spe))
metadata = left_join(metadata, cells_forClust, by = c("Image","CellID"))
spe$to_cluster = metadata$to_cluster

clustOut = harmonySOM(spe,
                      celltype_column = "to_cluster",
                      celltype_values = "Y",
                      clustMarkers = forClust,
                      batchCol = NULL)

# Cluster the 100 SOM codes into larger clusters
ccp = ConsensusClusterPlus(t(clustOut[[1]]$objects$som$codes[[1]]),
                            maxK = maxClust,
                            reps = 100, 
                            distance = "euclidean", 
                            seed = 220410, 
                            plot = NULL)

# Visualize delta area plot
CATALYST:::.plot_delta_area(ccp)

# Save UMAP, Heatmap, and Z-score graphs to 'ClustGraphs' using clustering results
dir.create("../ClustGraphs", showWarnings = FALSE)
spe_subset = clustGraphs(clustOut, ccp, clustNumber, "All", TRUE, "../ClustGraphs")

# Generate UMAP of individual marker expression values and save to 'ClustGraphs'
png(file.path(getwd(), "../ClustGraphs", "markerPlots.png"), width = 3000, height = 3000, res = 300) 
plot_list_harmony = multi_dittoDimPlot(spe_subset, var=rownames(spe_subset), reduction.use = "UMAP", assay = "norm_exprs", size = 0.2, list.out = TRUE) 
plot_list_harmony = lapply(plot_list_harmony, function(x) x + scale_color_viridis())
print(plot_grid(plotlist = plot_list_harmony))
dev.off()
```

## 4b) Export clusters to Mantis for viewing

```{r eval = FALSE, echo = FALSE, include = FALSE}
clust_celltypes = as.data.frame(colData(spe_subset))
clust_celltypes = clust_celltypes %>% 
  select(Image, CellID, som_clusters_corrected) 

write.table(clust_celltypes, "../MantisProject/Clustered_CellTypes.csv", sep=",",  col.names=FALSE, row.names=FALSE)
saveRDS(clust_celltypes, "RDSFiles/clustered_celltypes.rds")
```

## 4c) Rename clusters and re-export to Mantis

```{r eval = FALSE, echo = FALSE, include = FALSE}
## If you wish to rename clusters (eg. 1 is " T cell"), run his chunk to overwrite the '_final_celltypes.csv' file from above

# **** Enter names of clusters on right side then run this code - delete rows you don't need if you ran fewer clusters ****
clust_celltypes = readRDS("RDSFiles/clustered_celltypes.rds")
named_clusters = recode(spe_subset$som_clusters_corrected,
                            "1" = "T cell",
                            "2" = "B cell",
                            "3" = "C",
                            "4" = "D",
                            "5" = "E",
                            "6" = "F",
                            "7" = "G",
                            "8" = "H",
                            "9" = "I",
                            "10" = "J",
                            "11" = "K",
                            "12" = "L")

# Change current 'celltype' column
clust_celltypes = readRDS("RDSFiles/clustered_celltypes.rds")
named_celltypes = clust_celltypes
named_celltypes$som_clusters_corrected = named_clusters

spe_subset$celltype = named_clusters

write.table(named_celltypes, "../MantisProject/Annotated_CellTypes.csv", sep=",",  col.names=FALSE, row.names=FALSE)
saveRDS(named_celltypes, "RDSFiles/annotated_celltypes.rds")
```

## 4d) Re-assigning cells to new populations

```{r eval = FALSE, echo = FALSE}
## If you wish to re-assign certain cells to a different population, run this chunk

# **** Visualise marker expression for a celltype to determine an appropriate cut off for reassigning cells using 'moveCells' function on next line ****

# For example, here 'T cell' entries in are evaluated for 'CD3' expression with a cut-off of 0.4 
visMarker(spe_subset, "T cell", "CD3", 0.4)
```

```{r eval = FALSE, echo = FALSE}
# **** Assign cells from 'target' population to 'newTarget' based on 'value' of 'marker' being above/below 'direction' ****

# For example, reassign cells from 'T cell' population in to 'B' population if CD3 expression is greater than (>) 0.4
spe_subset = moveCells(spe_subset, target="B cell", newTarget="T cell", marker="CD3", value=0.4, direction="<")

# Make temporary column the new 'celltype' column
colData(spe_subset)$celltype = colData(spe_subset)$reassigned_celltype
colData(spe_subset)$reassigned_celltype = NULL

# Print updated UMAP with annotations (set 'do.label = FALSE' to remove labels)
UMAP_graph = dittoDimPlot(spe_subset, var = "celltype",
             reduction.use = "UMAP", size = 1.2,
             do.label = TRUE, labels.size = 2.5,
             legend.size = 4) +
    ggtitle("SOM clusters on UMAP, integrated cells")
UMAP_graph
ggsave(file.path("../ClustGraphs", "UMAP_labelled_annotated.png"), UMAP_graph, width = 6, height = 4.5)

# Save subsetted data
saveRDS(spe_subset, "RDSFiles/reassigned_spe.rds")

# Create new population CSV for viewing in Mantis
reassigned_celltypes = as.data.frame(colData(spe_subset)) %>%
  select(Image, ImageID, celltype)
write.table(reassigned_celltypes, "../MantisProject/Reassigned_CellTypes.csv", sep=",",  col.names=FALSE, row.names=FALSE)
saveRDS(reassigned_celltypes, "RDSFiles/reassigned_celltypes.rds")
```
