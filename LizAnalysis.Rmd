---
title: "NewIMCAnalysis"
output: html_document
date: "2024-01-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/oscar/Desktop/IMC/LizAnalysisTest/analysis")
```

## R Markdown

## Install Packages

```{r eval = FALSE, echo = FALSE}
install.packages("tidyverse",  repos = "http://cran.us.r-project.org")
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("FlowSOM")
BiocManager::install("dittoSeq")
BiocManager::install("imcRtools")
BiocManager::install("FuseSOM")
BiocManager::install("bluster")
BiocManager::install("kohonen")
if(!require(devtools)){
  install.packages("devtools") 
}
devtools::install_github("JinmiaoChenLab/Rphenograph")
BiocManager::install("bluster")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!requireNamespace("harmony", quietly = TRUE)) {
  BiocManager::install("harmony")
}

install.packages("magick")
install.packages("tiff")
install.packages("utils") 
install.packages("bioimagetools")
```

## Load in Packages

```{r eval = FALSE, echo = FALSE, include = False}
library(tidyverse)
library(stringr)
library(data.table)
library(FlowSOM)
library(shiny)
library(FuseSOM)
library(dplyr)
library(ggplot2)
library(cytomapper)
library(dittoSeq)
library(viridis)
library(RColorBrewer)
library(ggrepel)
library(EBImage)
library(mclust)
library(scuttle)
library(scater)
library(cowplot)
library(harmony)
library(BiocSingular)
library(Rphenograph)
library(igraph)
library(bluster)
library(BiocParallel)
library(CATALYST)
library(kohonen)
library(ConsensusClusterPlus)
library(pheatmap)
library(gridExtra)
library(magick)
library(tiff)
library(utils)
library(SpatialExperiment)
```

## Creating Dataframe from CellProfiler Output

```{r eval = FALSE, echo = FALSE}
# Load CSVs
cells =  read.csv("CellProfilerOutput/cell.csv")
panel = read.csv("../raw/panel.csv")
image = read.csv("CellProfilerOutput/Image.csv")

# Filter rows and columns
image = image %>%
  mutate(ROI = 1, Image = str_remove(FileName_FullStack , "_full\\.tiff")) %>%  
  select(-FileName_FullStack)
  
panel = panel %>%
  dplyr::filter(trimws(Target) != "") %>%
  mutate(Metal = Metal.Tag) %>% 
  select("Metal", "Target") %>%
  dplyr::filter(Metal != "Ir191")

# Join image data with cell data
cellsCombined = left_join(cells, image, by = join_by(ImageNumber))

# Define old name and what to change to.
rename_vec = c(
  "Image" = "Image",
  "ImageNumber" = "ImageID",
  "ROI" = "ROI",
  "ObjectNumber" = "CellID",
  "AreaShape_Area" = "Area",
  "AreaShape_Center_X" = "X",
  "AreaShape_Center_Y" = "Y")

# Change names in cellsCombined from old names to new names
names(cellsCombined) = ifelse(names(cellsCombined) %in% names(rename_vec), rename_vec[names(cellsCombined)], names(cellsCombined))

# Name marker columns
markers <- panel[,"Target"]

createSortedVector <- function(n) {
  numbers <- 1:n
  char_numbers <- as.character(numbers)
  sorted_char_numbers <- sort(char_numbers, method = "radix")
  sorted_numbers <- as.integer(sorted_char_numbers)
  return(sorted_numbers)
}

ordered_markers = markers[createSortedVector(length(markers))]
colnames(cellsCombined)[6:(length(markers)+5)] = ordered_markers

# Keep only desired columns
meta = unname(sapply(strsplit(rename_vec, " = "), '[', 1))
keep = c(meta,ordered_markers)
cellsCombined = cellsCombined %>% select(all_of(keep))

cellsCombined$X = as.integer(cellsCombined$X)
cellsCombined$Y = as.integer(cellsCombined$Y)
cellsCombined$Area = as.integer(cellsCombined$Area)

dir.create("RDSFiles", showWarnings = FALSE)
saveRDS(cellsCombined, "RDSFiles/IMCData.rds")
```

## Creating SpatialExperiment ('spe') Object

```{r eval = FALSE, echo = FALSE}
# Marker expression, other cellular features and spatial features (co-ordinates) are read and merged into a spatial experiment object
cells =  read.csv("CellProfilerOutput/cell.csv")
dt = readRDS("RDSFiles/IMCData.rds")

# Split data into marker intensities, metadata and co-ordinates
markers = colnames(dt)[8:(length(markers)+7)]
baseCol = colnames(dt)[!(colnames(dt) %in% markers)]
baseCol = setdiff(baseCol, c("X","Y"))

counts <- dt[, markers]
meta <- dt[, baseCol]
coords <- dt[, c("X", "Y")]

# Scale data back up (if processed through cell profiler)
counts = counts*65535

# Create spatial object
spe <- SpatialExperiment(assays = list(counts = t(counts)),
                          colData = meta, 
                          sample_id = as.character(meta$ImageID),
                          spatialCoords = as.matrix(coords))

# Set DonorID (dummy variable here)
spe$DonorID = as.factor(spe$ImageID)

# Change variables to 'factor' type
spe$Image = as.factor(spe$Image)
spe$ImageID = as.factor(spe$ImageID)
spe$ROI = as.factor(spe$ROI)

colnames(spe) = paste0(spe$ImageID, "_", spe$CellID)

# Plot current distribution
dittoRidgePlot(spe, var = "CD3", group.by = "ImageID", assay = "counts", max=10) +
    ggtitle("CD3 - before transformation")

# Plot distribution after arcsinh transforming data
assay(spe, "exprs") = asinh(counts(spe))
dittoRidgePlot(spe, var = "CD3", group.by = "ImageID", assay = "exprs", max = 10) +
    ggtitle("CD3 - after arcsinh transformation")


### Scale (z-transform) the arcsinh-transformed data
# Extract the expression matrix and image information
exprs_matrix <- assay(spe, "exprs")
images <- spe$Image

# Get unique images and channels
unique_images <- unique(images)
channels <- rownames(exprs_matrix)

# Prepare a matrix to store scaled expressions
scaled_exprs_matrix <- matrix(NA, nrow = nrow(exprs_matrix), ncol = ncol(exprs_matrix))
rownames(scaled_exprs_matrix) <- channels
colnames(scaled_exprs_matrix) <- colnames(exprs_matrix)

# Iterate over each image and channel to scale
for (image in unique_images) {
  image_indices <- which(images == image)
  
  for (channel in channels) {
    channel_data <- exprs_matrix[channel, image_indices]
    
    # Perform Z-normalization if there are enough non-NA values
    scaled_data <- scale(channel_data)
    scaled_exprs_matrix[channel, image_indices] <- scaled_data
  }
}

# Assign the scaled data back to the assay
assay(spe, "scaled_exprs") <- scaled_exprs_matrix

# Simple min imputation example - this replaces NA values generated by Z-norm, with the min value of that channel across all images
exprs_data <- assay(spe, "scaled_exprs")

for (i in 1:ncol(exprs_data)) {
  column_values <- exprs_data[, i]
  exprs_data[is.na(column_values), i] <- min(column_values, na.rm = TRUE)
}
assay(spe, "scaled_exprs") <- exprs_data

# Plot distribution after z-transforming the data
dittoRidgePlot(spe, var = "CD3", group.by = "ImageID", assay = "scaled_exprs", max=5) + ggtitle("CD3 - after z-transformation")

### Normalise values between 0 and 1 for each image
# Extract the expression matrix and image information
exprs_matrix <- assay(spe, "exprs")
images <- spe$Image

# Get unique images and channels
unique_images <- unique(images)
channels <- rownames(exprs_matrix)

# Prepare a matrix to store normalized expressions
norm_exprs_matrix <- matrix(NA, nrow = nrow(exprs_matrix), ncol = ncol(exprs_matrix))
rownames(norm_exprs_matrix) <- channels
colnames(norm_exprs_matrix) <- colnames(exprs_matrix)

# Iterate over each image and channel to normalize
for (image in unique_images) {
    image_indices <- which(images == image)
    
    for (channel in channels) {
        channel_data <- exprs_matrix[channel, image_indices]
        
        # Apply min-max normalization
        min_val <- min(channel_data, na.rm = TRUE)
        max_val <- max(channel_data, na.rm = TRUE)
        range_val <- max_val - min_val
        
        # Avoid division by zero if all values in channel_data are the same
        if (range_val != 0) {
            norm_data <- (channel_data - min_val) / range_val
        } else {
            norm_data <- rep(0, length(channel_data))  
        }

        norm_exprs_matrix[channel, image_indices] <- norm_data
    }
}

# Assign the normalized data back to the assay
assay(spe, "norm_exprs") <- norm_exprs_matrix

# Plot distribution after normalising the data
dittoRidgePlot(spe, var = "CD3", group.by = "ImageID", assay = "norm_exprs", max=1.0) + ggtitle("CD3 - after normalising")

# Create an entry that specifies which markers are useful for clustering
forClust = markers
rowData(spe)$use_channel  <- rownames(spe) %in% forClust

### Assigning colour palettes
color_vectors <- list()

# DonorID
donor_ids <- unique(spe$DonorID)
# Create a color vector that repeats  if there are more than 12 unique DonorIDs
donor_colors <- brewer.pal(12, name = "Paired")[as.numeric(donor_ids) %% 12 + 1]
# Set the names of the colors to match the unique DonorIDs
DonorID <- setNames(donor_colors, donor_ids)
color_vectors$DonorID <- DonorID

# ImageID
image_ids <- unique(spe$ImageID)
# Create a color vector that repeats  if there are more than 12 unique ImageIDs
image_colors <- brewer.pal(12, name = "Paired")[as.numeric(image_ids) %% 12 + 1]
# Set the names of the colors to match the unique ImageIDs
ImageID <- setNames(image_colors, image_ids)
color_vectors$ImageID <- ImageID

metadata(spe)$color_vectors <- color_vectors

# Add a universal CellID column
colData(spe)$uCellID = 1:length(spe$CellID) 
a = as.data.frame(colData(spe))
a = a %>%
  group_by(Image) %>%
  dplyr::filter(row_number()==1) %>%
  select(Image, ImageID, uCellID)
# Write a csv with an ImageID to ImShort to Image name to uCellID key.
write.csv(a, "Image_uCellID_key.csv")
rm(a)

saveRDS(spe, "RDSFiles/spe.rds")
```

## Export Mantis '\_counts.csv' file (run once only)

```{r eval = FALSE, echo = FALSE}
# Export the marker_counts.csv sheet
spe = readRDS("RDSFiles/spe.rds")

for (img in unique(colData(spe)$Image)) {
  # Extract the full assay data (markers) and transpose it
  markers = rownames(spe)
  marker_data <- t(assay(spe, "norm_exprs"))
  
  # Convert marker data to a data frame, if it's not already
  marker_data_df <- as.data.frame(marker_data)
  
  # Add metadata (including CellID and image information) as columns to marker_data_df
  metadata <- as.data.frame(colData(spe))
  marker_data_df <- cbind(metadata, marker_data_df)
  
  # Filter the combined data to keep only rows corresponding to images in imMantis
  filtered_data <- marker_data_df[marker_data_df$Image %in% c(img), ]
  
  # Select only relevant columns (eg. image name, CellID, list of markers)
  selected_columns <- c("Image", "CellID", markers) 
  final_data <- filtered_data[, selected_columns]
  
  # Check if all entries in the 'Image' column are the same (only one image)
  if (length(unique(final_data$Image)) == 1) {
      final_data$Image <- NULL
  }
  
  # Rename the remaining columns if necessary
  colnames(final_data)[colnames(final_data) %in% c("CellID")] <- c("label")
  
  # Save the final filtered and selected data to a CSV file
  dir.create("mantis_CSVs", showWarnings = FALSE)
  write.csv(final_data, paste0("mantis_CSVs/", img, "_counts.csv"), row.names = FALSE)
}
```

## 1. Custom functions for annotation

```{r eval = FALSE, echo = FALSE}
# Install and load required packages
packages <- c("BiocManager", "SingleCellExperiment", "umap", "FlowSOM", "dplyr", "ggplot2", "gridExtra", "magick", "viridis", "tiff")

for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    if (pkg == "BiocManager") {
      install.packages(pkg)
    } else if (pkg %in% c("SingleCellExperiment", "FlowSOM")) {
      BiocManager::install(pkg)
    } else {
      install.packages(pkg)
    }
  }
  library(pkg, character.only = TRUE)
}

## Subset cells, batch correct and  SOM cluster
harmonySOM <- function(spe, compartment_vector = NULL, celltype_column = NULL, celltype_values = NULL, clustMarkers = NULL, batchCol = NULL) {
  # Function processes single-cell data for UMAP, PCA, and SOM clustering.
  # - spe: Single-cell experiment object.
  # - celltype_column, celltype_values, compartment_vector: Optional parameters for subsetting.
  # - clustMarkers: Optional. Markers to use for clustering. Uses 'use_channel' if not provided.
  # - batchCol: Optional. Column name for batch correction groups. If NULL, skip batch correction.
  # Returns a list containing the SOM clustered data and subsetted spe data

  # Assign variable names
  speData = "norm_exprs"
  pcaName = "PCA_norm"
  umapName = "UMAP"  # Unified UMAP reduction name

  # Conditional subsetting
  subCells <- rep(TRUE, ncol(spe))
  if (!is.null(celltype_column) && !is.null(celltype_values)) {
      subCells <- subCells & (!is.na(colData(spe)[[celltype_column]])) & (colData(spe)[[celltype_column]] %in% celltype_values)
  }
  if (!is.null(compartment_vector)) {
      subCells <- subCells & (colData(spe)$Compartment %in% compartment_vector)
  }

  spe_subset <- spe[, subCells]

  # Update 'use_channel' based on clustMarkers
  if (!is.null(clustMarkers)) {
      if (!all(clustMarkers %in% rownames(spe_subset))) {
          stop("Some of the specified markers for clustering do not exist in rowData.")
      }
      rowData(spe_subset)$use_channel <- rownames(spe_subset) %in% clustMarkers
  } else {
      if (!"use_channel" %in% names(rowData(spe_subset))) {
          stop("The 'use_channel' does not exist in rowData.")
      }
  }

  # Run PCA on the subset
  spe_subset <- runPCA(spe_subset, subset_row = rowData(spe_subset)$use_channel, exprs_values = speData, ncomponents = 30, BSPARAM = ExactParam())
  reducedDims(spe_subset)[[pcaName]] <- reducedDims(spe_subset)[["PCA"]]

  # Harmony batch correction (if specified)
  if (!is.null(batchCol)) {
      set.seed(230616)
      out <- RunHarmony(spe_subset, group.by.vars = batchCol)
      stopifnot(all.equal(colnames(spe_subset), colnames(out)))
      reducedDim(spe_subset, umapName) <- reducedDim(out, "HARMONY")
  } else {
      # Run UMAP without batch correction
      set.seed(220228)
      spe_subset <- runUMAP(spe_subset, subset_row = rowData(spe_subset)$use_channel, exprs_values = speData, name = umapName)
  }

  # Perform SOM clustering
  set.seed(220410)
  som.out <- clusterRows(reducedDim(spe_subset, umapName), SomParam(100), full = TRUE)

  return(list(som.out = som.out, spe_subset = spe_subset))
}


#Example Useage
# clustOut = harmonySOM(spe, "LA", "celltype_flowjo", "Tcell")


## choose cluster number, generate graphs and output spe_subset with cluster numbers annotated
clustGraphs <- function(clustOutF, ccpF, ccp_clustNum, graph_type, annotate_labels, save_path,  assayName = "norm_exprs") {
  # Function clustGraphs: Generates and saves UMAP, Heatmap, and Z-score graphs based on clustering results.
  # - clustOutF: Output of harmonySOM function which contains in entry 1 the SOM clustered data and entry 2 the subsetted SingleCellExperiment object with clustering information.
  # - ccpF: is the ccp variable which holds the output of ConsensusClusterPlus Clustering.
  # - ccp_clustNum: Numeric value of clusters from ConsensusClusterPlus.
  # - graph_type: Type of graph to generate ('All', 'UMAP', 'Heatmap', 'Zscore').
  # - annotate_labels: Boolean to indicate whether to annotate labels on graphs.
  # - save_path: Folder path for saving the generated graphs.
  # Returns speF which has the cluster number annotations added as a metadata column
  
  set.seed(220228)

  somOutput = clustOutF[[1]]
  speF = clustOutF[[2]]
  # Check if save_path has a trailing slash and add one if it doesn't
  if (substr(save_path, nchar(save_path), nchar(save_path)) != "/") {
    save_path <- paste0(save_path, "/")
  }
  
  # Convert ccp_clustNum to string for file naming
  cluster_str <- as.character(ccp_clustNum)

  # Link ConsensusClusterPlus clusters with SOM codes and save in object
  som.cluster <- ccpF[[ccp_clustNum]][["consensusClass"]][somOutput$clusters]
  speF$som_clusters_corrected <- as.factor(som.cluster)

  # Determine graph types and generate accordingly
  if (graph_type %in% c("All", "UMAP")) {

    p1 <- dittoDimPlot(speF, var = "som_clusters_corrected", 
                       reduction.use = "UMAP", size = 1.2,
                       do.label = annotate_labels, labels.size = 2.5,
                       legend.size = 4) +
          ggtitle("SOM clusters on UMAP, integrated cells")
    print(p1)
    ggsave(paste0(save_path, cluster_str, "_UMAP_labelled.png"), p1, width = 6, height = 4.5)
  }
  
  if (graph_type %in% c("All", "Heatmap")) {
    # Choose the smaller number between the total number of cells and 2000
    cell_count <- min(ncol(speF), 2000)
    cur_cells <- sample(seq_len(ncol(speF)), cell_count)
    p1 <- dittoHeatmap(speF[,cur_cells], 
                       genes = rownames(speF)[rowData(speF)$use_channel],
                       assay = assayName, scale = "none",
                       heatmap.colors = viridis(100), 
                       annot.by = c("som_clusters_corrected", "DonorID"),
                       annot.colors = c(dittoColors(1)[1:length(unique(speF$som_clusters_corrected))],
                                        metadata(speF)$color_vectors$DonorID))
    print(p1)
    ggsave(paste0(save_path, cluster_str, "_Heatmap.png"), p1, width = 8.5, height = 6, dpi = 300)
  }

  if (graph_type %in% c("All", "Zscore")) {
    celltype_mean <- aggregateAcrossCells(as(speF, "SingleCellExperiment"),  
                         ids = speF$som_clusters_corrected, 
                         statistics = "mean",
                         use.assay.type = "exprs")
    p1 <- dittoHeatmap(celltype_mean,
                       genes = rownames(speF)[rowData(speF)$use_channel], 
                       assay = "exprs", 
                       cluster_rows = TRUE, 
                       annot.by = c("som_clusters_corrected"))
    print(p1)
    ggsave(paste0(save_path, cluster_str, "_Zscore.png"), p1, width = 8.5, height = 6, dpi = 300)
  }
  
  return(speF)
}

# Example Useage
# spe_subset = clustGraphs(clustOut, ccp, 12, "All", TRUE, "LA_Tcell")


## Export new clusters for validation in Mantis Viewer
mantis_pop <- function(image_name, suffix, cellSubs) {
  df = celltype_by_image[[image_name]]
  rownames(df) = df$CellID
  df = as.data.frame(df) %>%
    select(cellSubs)
  write.table(df, paste0("mantis_CSVs/", image_name, suffix, ".csv"), sep=",",  col.names=FALSE)
}

## Visualise marker histogram to find cut of for filtering cells
visMarker <- function(speF, target, marker, value, celltype_col = "celltype", assayF = "norm_exprs", group_by = "DonorID", overall_title = NULL, target_title = NULL) {
  # Remove NAs
  plotData <- speF[, !is.na(colData(speF)[[celltype_col]]) & colData(speF)[[celltype_col]] == target]
  plotData$All <- rep("All", length(colnames(plotData)))
  
  # Create titles if not provided
  if (is.null(overall_title)) {
    overall_title <- paste("Overall Expression of", marker, "in", target, "cells")
  }
  if (is.null(target_title)) {
    target_title <- paste("Expression of", marker, "in", target, "cells by", group_by)
  }

  # Create the first plot by specified group
  plot1 <- dittoRidgePlot(plotData, var = marker, group.by = group_by, assay = assayF, max = 1) +
    ggtitle(target_title) +
    geom_vline(xintercept = value, col = "black", lwd = 1.5, linetype = "dashed")

  # Create a second plot for all cells together
  plot2 <- dittoRidgePlot(plotData, var = marker, group.by = "All", assay = assayF, max = 1) +
    ggtitle(overall_title) +
    geom_vline(xintercept = value, col = "red", lwd = 1.5, linetype = "dashed")

  # Print both plots on the same screen
  grid.arrange(plot1, plot2, ncol = 2)
}


# Example usage:
# visMarker(spe_subset, "celltype", "Cycling DC", "CD20", 0.5, group_by = "DonorID")


## Track population reassignments in real-time in a table written to working directory

# Check if the tracking_table already exists in the global environment
if (file.exists("clusterModTracker.csv")) {
  # Load the existing tracking table from the file
  tracking_table <<- read.csv("clusterModTracker.csv", stringsAsFactors = FALSE)
} else {
  # Create a new tracking table if the file doesn't exist
  tracking_table <<- data.frame(
    from = character(),
    to = character(),
    condition = character(),
    stringsAsFactors = FALSE
  )
}

update_tracking <- function(flowjo_celltype, from_pop, to_pop, marker, value, direction) {
    
    # Create a new entry
    new_entry <- data.frame(flowjo_celltype = flowjo_celltype,
                            from_pop = from_pop,
                            to_pop = to_pop,
                            condition = paste(marker, direction, as.character(value)),
                            stringsAsFactors = FALSE)
    
    # Check for duplicate across all variables
    duplicate_index <- with(tracking_table, 
                            which(flowjo_celltype == new_entry$flowjo_celltype &
                                  from_pop == new_entry$from_pop &
                                  to_pop == new_entry$to_pop &
                                  condition == new_entry$condition)
                            )
    
    if (length(duplicate_index) > 0) {
        # Replace the duplicate entry
        tracking_table[duplicate_index, ] <- new_entry
    } else {
        # Append the new entry
        tracking_table <<- rbind(tracking_table, new_entry)
    }
    
    write.csv(tracking_table, "clusterModTracker.csv", row.names = FALSE)
}

# Example Usage
# update_tracking("Cycling DC", "B cell", "CD20", 0.5, ">")
# update_tracking("Memory T", "Treg", "FoxP3", 0.3, "<")



## Move cells from one population to another one based on specifications

# Assigns cells from "target" population defined in column 'celltype_col' 
# to "newTarget" in a new column called *reassigned_celltype* based on 'value' of
# 'marker' in 'assayF' being above/below 'direction'.
moveCells <- function(speF, target, newTarget, marker, value, direction, celltype_col = "celltype", assayF = "norm_exprs") {
  # Ensure the 'reassigned_celltype' column is present
  colData(speF)$reassigned_celltype <- colData(speF)[[celltype_col]]
  
    # Calculate counts before and after reassignment
  counts_before <- data.frame(colData(speF)) %>%
    dplyr::filter(reassigned_celltype == target) %>%
    group_by(DonorID) %>%
    summarize(counts_before = n())
  
  # Determine cells to reassign based on the marker expression and direction
  if (direction == ">") {
    cellRemove <- assay(speF, assayF)[marker, ] > value
  } else if (direction == "<") {
    cellRemove <- assay(speF, assayF)[marker, ] < value
  } else {
    stop("Invalid direction. Use '>' or '<'.")
  }

  # Reassign cell types
  cellTarget <- colData(speF)[[celltype_col]] == target
  reassigned <- cellTarget & cellRemove
  colData(speF)$reassigned_celltype[reassigned] <- newTarget

  counts_after <- data.frame(colData(speF)) %>%
    dplyr::filter(reassigned_celltype == target) %>%
    group_by(DonorID) %>%
    summarize(counts_after = n())

  # Combine the counts
  counts_combined <- merge(counts_before, counts_after, by = "DonorID", all = TRUE)
  counts_combined[is.na(counts_combined)] <- 0

  # Sum of counts before and after
  total_counts <- counts_combined %>%
    summarise(
      total_counts_before = sum(counts_before, na.rm = TRUE),
      total_counts_after = sum(counts_after, na.rm = TRUE)
    )

  # Print both outputs to the console
  print(counts_combined)
  print(total_counts)
  
  # Update tracking table
  update_tracking(colData(speF)$celltype_flowjo[1], target, newTarget, marker, value, direction)
  
  return(speF)
}

# Example usage:
# moveCells(spe_subset, "Cycling DC", "B cell", "CD20", 0.5, ">")
```

## 2a. FlowJo export

```{r eval = FALSE, echo = FALSE, include = FALSE}
spe = readRDS("RDSFiles/spe.rds")
image = read.csv("CellProfilerOutput/image.csv") %>%
  mutate(ImageName = str_remove(FileName_FullStack , "_full\\.tiff")) %>%  
  select(-FileName_FullStack) %>%
  dplyr::rename(ImageID = ImageNumber)

# Install and load the flowCore package
if (!requireNamespace("flowCore", quietly = TRUE)) {
  install.packages("flowCore")
}
library(flowCore)

# Function to process each image and write to FCS
write_fcs <- function(data, image_id) {
  # Remove 'ImageID' and 'ImageName' column and ensure the rest is numeric
  subset_data <- as.matrix(data[, -c(1, (ncol(data)-1):ncol(data))])
  subset_data <- apply(subset_data, 2, as.numeric)
  # Ensure column names are set
  colnames(subset_data) <- make.names(colnames(subset_data))
  # Convert to flowFrame
  ff <- flowFrame(subset_data)
  # Write to FCS
  fcs_filename <- paste0("../FlowJo/", image_id, ".fcs")
  write.FCS(ff, file = fcs_filename)
}

metadata = as.data.frame(colData(spe))
metadata2 = metadata %>%
  select(ImageID, uCellID, CellID, Area)

# Multiply by 1000 to match scale of visualisation in flowjo.
assayData = as.data.frame(t(assay(spe, "norm_exprs")))*10^3

# Combine metadata and assay data
df = cbind(metadata2, as.data.frame(spatialCoords(spe)), assayData)
df$ImageID = as.numeric(df$ImageID)
df = df %>%
  left_join(image, by="ImageID") %>%
  mutate(TempImageName = gsub("_.*", "", ImageName)) %>%
  group_by(TempImageName) %>%
  mutate(Y = (Y - max(Y))*(-1))

split_data = split(df, df$ImageName)
dir.create("../FlowJo", showWarnings = FALSE)
dir.create("../FlowJo/exports", showWarnings = FALSE)
lapply(names(split_data), function(name) write_fcs(split_data[[name]], name))
```

## 2b. View in Mantis and gate

```{r eval = FALSE, echo = FALSE}
panel = read.csv("../raw/panel.csv")
dir.create("../MantisProject", showWarnings = FALSE)
tiffs = list.files("full_images", pattern = "\\.tiff$")
csvs = list.files("full_images", pattern = "\\.csv$")

for (x in seq_along(tiffs)) {
  cur_img = substr(tiffs[x], 1, nchar(tiffs[x]) - 10)
  dir.create(paste0("../MantisProject/", cur_img), showWarnings = FALSE)
  cur_tiff = readTIFF(paste0("full_images/", tiffs[x]), all=TRUE)
  cur_csv = read.csv(paste0("full_images/", csvs[x]), header=FALSE)$V1
  for (channel in seq_along(cur_tiff)) {
    metal_tag = cur_csv[channel]
    marker = panel$Target[panel$Metal.Tag == metal_tag]
    filename = paste0("../MantisProject/", cur_img, "/", marker, ".tiff")
    mat = cur_tiff[[channel]]*65535
    writeTIFF((mat-min(mat))/(max(mat)-min(mat)), filename)
  }
}

seg_list = list.files("segmentation_masks", pattern = "\\.tif$", full.names = TRUE)
for (x in seg_list) {
  cur_img = substr(x, 20, nchar(x) - 23)
  from = x
  to = paste0("../MantisProject/", cur_img, "/SegmentationFile.tif")
  file.copy(from, to)
}

concat_df = data.frame()
for (x in list.files("mantis_CSVs", pattern = "_counts\\.csv$", full.names=TRUE)) {
  cur_img = substr(x, 13, nchar(x) - 11)
  df = read.csv(x) %>%
    dplyr::rename(`Segment ID` = label)
  df = cbind(`Image Folder Name` = rep(cur_img, nrow(df)), df)
  concat_df = rbind(concat_df, df)
}
write.csv(concat_df, "../MantisProject/marker_counts.csv", row.names = FALSE)
```

## 2c. FlowJo cluster import

```{r eval = FALSE, echo = FALSE}
# List of required packages
required_packages <- c("dplyr", "readr", "SingleCellExperiment", "tidyr")

# Install and load required packages
for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    if (pkg == "SingleCellExperiment") {
      if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
      }
      BiocManager::install(pkg)
    } else {
      install.packages(pkg)
    }
  }
  library(pkg, character.only = TRUE)
}

# Load in 'spe' object
spe = readRDS("RDSFiles/spe.rds")

#Remove celltype column if exists
colData(spe)$celltype_flowjo = NULL

# Read in spreadsheets from export folder and store in a list
temp = list.files(path = "../FlowJo/exports", pattern = "*.csv", full.names = TRUE)

temp = lapply(temp, function(x) {
  name = basename(x)
  name = as.character(name)
  a = read.csv(x, header = T)
  a = as.data.frame(a)
  celltype = sub("\\.csv$", "", name)
  a$celltype_flowjo = rep(celltype, nrow(a))
  return(a)
})

# Merge the list into a single dataframe by binding rows. 
data_raw = bind_rows(temp)
rm(temp)

data_raw = as.data.frame(data_raw)
data_raw$celltype_flowjo = as.factor(data_raw$celltype_flowjo)

# Remove duplicate entries by choosing one from them (eg. prioritise APCs)
data_raw <- data_raw %>%
  group_by(uCellID) %>%
  # arrange(celltype_flowjo != "APC", .by_group = TRUE) %>%
  dplyr::filter(!duplicated(uCellID)) %>%
  ungroup() %>%
  select(uCellID, celltype_flowjo)

# Merge 'celltype_flowjo' into 'spe' metadata
metadata = as.data.frame(colData(spe))
metadata <- left_join(metadata, data_raw, by = c("uCellID"))

# Update the metadata in 'spe'
colData(spe)$celltype_flowjo <- metadata$celltype_flowjo

saveRDS(spe, "RDSFiles/spe.rds")
```

## 3. Export FlowJo Annotations to Mantis

```{r eval = FALSE, echo = FALSE, include = FALSE}
# Run after importing FlowJo annotations - will write a '_FlowJo_celltypes.csv' file 
celltype_info = colData(spe)[, c("Image", "CellID", "celltype_flowjo")] %>%
  na.omit()

celltype_by_image = split(celltype_info, celltype_info$Image)
lapply(names(celltype_by_image), mantis_pop, suffix="_FlowJo_celltypes", cellSubs="celltype_flowjo")

concat_df = data.frame()
for (x in list.files("mantis_CSVs", pattern = "_FlowJo_celltypes\\.csv$", full.names=TRUE)) {
  tryCatch({
    df = read.csv(x, header = FALSE)
    cur_img = substr(x, 13, nchar(x) - 21)
    df = cbind(Image = rep(cur_img, nrow(df)), df)
    concat_df = rbind(concat_df, df)
  }, error = function(e) {
  })
}
write.table(concat_df, "../MantisProject/FlowJo_celltypes.csv", sep = ",", col.names = FALSE, row.names = FALSE)
```

## 4a. SOM clustering

```{r eval = FALSE, echo = FALSE}
## Run all code below.  For comments encased in '**** ****', read the comments and make any required changes to code below before running it.

# **** Select the population (from your FlowJo populations) you wish to cluster on ****
pop_to_cluster = "CD3+_a1"

# List of required packages
required_packages <- c("dplyr", "readr", "SingleCellExperiment", "ggplot2", "gridExtra", "magick", "tiff", "viridis", "ConsensusClusterPlus")

# Install and load required packages
for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    if (pkg == "SingleCellExperiment" || pkg == "ConsensusClusterPlus") {
      if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
      }
      BiocManager::install(pkg)
    } else {
      install.packages(pkg)
    }
  }
  library(pkg, character.only = TRUE)
}

spe = readRDS("RDSFiles/spe.rds")

## **** Variables: ****
#   - Maximum clusters for CCP function to generate
maxClust = 30
#   - Cluster number used or analysis (must be less than maxClust)
clustNumber = 12
#   - Markers for clustering (note all markers are used by default) 
forClust = c("CD45RO", "CD8", "CD45", "CXCR3", 
             "CCR7", "CCR6", "Ki67",
             "CD69", "CD3", "CD4", "HLADR")


## **** FlowSOM clustering on Spatial Object 'spe' ****
#   - If wanting to cluster on a subset of cells, specify the celltype_column (eg. 'celltype_flowjo') and and celltype_values (eg. 'T cell')
#   - To use a subset of markers for clustering, specify the subset in forClust above and set 'clustMarkers = forClust
#   - If wanting to batch correct (using Harmony specify the column which indicates unique batches
clustOut = harmonySOM(spe, 
                      celltype_column = "celltype_flowjo", 
                      celltype_values = pop_to_cluster, 
                      clustMarkers = forClust, 
                      batchCol = NULL)

# Cluster the 100 SOM codes into larger clusters
ccp = ConsensusClusterPlus(t(clustOut[[1]]$objects$som$codes[[1]]),
                            maxK = maxClust,
                            reps = 100, 
                            distance = "euclidean", 
                            seed = 220410, 
                            plot = NULL)

# Visualize delta area plot
CATALYST:::.plot_delta_area(ccp)

# Save UMAP, Heatmap, and Z-score graphs to 'ClustGraphs' using clustering results
dir.create("../ClustGraphs", showWarnings = FALSE)
spe_subset = clustGraphs(clustOut, ccp, clustNumber, "All", TRUE, "../ClustGraphs")

# Generate UMAP of individual marker expression values and save to 'ClustGraphs'
png(file.path(getwd(), "../ClustGraphs", "markerPlots.png"), width = 3000, height = 3000, res = 300) 
plot_list_harmony = multi_dittoDimPlot(spe_subset, var=rownames(spe_subset), reduction.use= "UMAP", assay = "norm_exprs", size = 0.2, list.out = TRUE) 
plot_list_harmony <- lapply(plot_list_harmony, function(x) x + scale_color_viridis())
print(plot_grid(plotlist = plot_list_harmony))
dev.off()
```

## 4b. Export clusters to Mantis for viewing

```{r eval = FALSE, echo = FALSE, include = FALSE}
# Merge 'spe_subset' labels back into main 'spe' object and export for Mantis viewing
sMetadata = as.data.frame(colData(spe_subset))
sMetadata <- sMetadata %>% select(uCellID, som_clusters_corrected)
metadata = as.data.frame(colData(spe))
metadata$celltype <- NULL
metadata <- left_join(metadata, sMetadata, by = c("uCellID"))
colData(spe)$celltype <- metadata$som_clusters_corrected

# Export unique celltypes in 'celltype' column as a '_final_celltypes.csv' file
celltype_info = colData(spe)[, c("Image", "CellID", "celltype")] %>% na.omit()
celltype_by_image = split(celltype_info, droplevels(celltype_info$Image))
lapply(names(celltype_by_image), mantis_pop, suffix="_final_celltypes", cellSubs="celltype")

concat_df = data.frame()
for (x in list.files("mantis_CSVs", pattern = "_final_celltypes\\.csv$", full.names=TRUE)) {
  tryCatch({
    df = read.csv(x, header = FALSE)
    cur_img = substr(x, 13, nchar(x) - 20)
    df = cbind(Image = rep(cur_img, nrow(df)), df)
    concat_df = rbind(concat_df, df)
  }, error = function(e) {
  })
}
write.table(concat_df, "../MantisProject/final_celltypes.csv", sep = ",", col.names = FALSE, row.names = FALSE)
```

## 4c. Rename clusters and re-export to Mantis

```{r eval = FALSE, echo = FALSE, include = FALSE}
## If you wish to rename clusters (eg. 1 is " T cell"), run his chunk to overwrite the '_final_celltypes.csv' file from above

# **** Enter names of clusters on right side then run this code - delete rows you don't need if you ran fewer clusters ****
som_clusters_corrected = recode(spe_subset$som_clusters_corrected,
                            "1" = "T cell",
                            "2" = "B cell",
                            "3" = "C",
                            "4" = "D",
                            "5" = "E",
                            "6" = "F",
                            "7" = "G",
                            "8" = "H",
                            "9" = "I",
                            "10" = "J",
                            "11" = "K",
                            "12" = "L")

# Change current 'celltype' column
spe_subset$celltype = som_clusters_corrected

# Export unique celltypes in 'celltype' column as a '_final_celltypes.csv' file
celltype_info = colData(spe_subset)[, c("Image", "CellID", "celltype")] %>% na.omit()
celltype_by_image = split(celltype_info, droplevels(celltype_info$Image))
lapply(names(celltype_by_image), mantis_pop, suffix="_final_celltypes", cellSubs="celltype")

concat_df = data.frame()

for (x in list.files("mantis_CSVs", pattern = "_final_celltypes\\.csv$", full.names=TRUE)) {
  tryCatch({
    df = read.csv(x, header = FALSE)
    cur_img = substr(x, 13, nchar(x) - 20)
    df = cbind(Image = rep(cur_img, nrow(df)), df)
    concat_df = rbind(concat_df, df)
  }, error = function(e) {
  })
}

write.table(concat_df, "../MantisProject/final_celltypes.csv", sep = ",", col.names = FALSE, row.names = FALSE)
```

## 4d. Re-assigning cells to new populations

```{r eval = FALSE, echo = FALSE}
## If you wish to re-assign certain cells to a different population, run this chunk

# **** Visualise marker expression for a celltype to determine an appropriate cut off for reassigning cells using 'moveCells' function on next line ****

# For example, here 'T cell' entries in are evaluated for 'CD3' expression with a cut-off of 0.4 
visMarker(spe_subset, "T cell", "CD3", 0.4)
```

```{r eval = FALSE, echo = FALSE}
# **** Assign cells from 'target' population to 'newTarget' based on 'value' of 'marker' being above/below 'direction' ****

# For example, reassign cells from 'T cell' population in to 'B' population if CD3 expression is greater than (>) 0.4
spe_subset = moveCells(spe_subset, target="T cell", newTarget="B cell", marker="CD3", value=0.4, direction=">")

# Make temporary column the new 'celltype' column
colData(spe_subset)$celltype = colData(spe_subset)$reassigned_celltype
colData(spe_subset)$reassigned_celltype = NULL

# Print updated UMAP with annotations (set 'do.label = FALSE' to remove labels)
UMAP_graph = dittoDimPlot(spe_subset, var = "celltype",
             reduction.use = "UMAP", size = 1.2,
             do.label = TRUE, labels.size = 2.5,
             legend.size = 4) +
    ggtitle("SOM clusters on UMAP, integrated cells")
UMAP_graph
ggsave(file.path("../ClustGraphs", "UMAP_labelled_annotated.png"), UMAP_graph, width = 6, height = 4.5)

# Save subsetted data with appropriate name.
saveRDS(spe_subset, "RDSFiles/spe_T_cells.rds")

# Create new population CSV for viewing in Mantis
celltype_info = colData(spe_subset)[, c("Image", "CellID", "celltype")] %>%
  na.omit()
celltype_by_image = split(celltype_info, celltype_info$Image)
lapply(names(celltype_by_image), mantis_pop, suffix="_final_celltypes", cellSubs="celltype")

concat_df = data.frame()
for (x in list.files("mantis_CSVs", pattern = "_final_celltypes\\.csv$", full.names=TRUE)) {
  tryCatch({
    df = read.csv(x, header = FALSE)
    cur_img = substr(x, 13, nchar(x) - 20)
    df = cbind(Image = rep(cur_img, nrow(df)), df)
    concat_df = rbind(concat_df, df)
  }, error = function(e) {
  })
}
write.table(concat_df, "../MantisProject/final_celltypes.csv", sep = ",", col.names = FALSE, row.names = FALSE)
```
