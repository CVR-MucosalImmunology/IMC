---
title: "R IMC Pipeline"
output: html_document
---

# R IMC Pipeline

**Authors:** oscardong4\@gmail.com and heeva.baharlou\@gmail.com (20/05/2024)

## 0. Setting Up

#### a) Set Your `analysis` Directory

Change the `root.dir` variable to your `analysis` folder directory, then run the chunk below.

```{r setup, include=FALSE}
source("https://raw.githubusercontent.com/CVR-MucosalImmunology/IMC/main/.assets/functions.R")
if (!require("knitr", quietly = TRUE)) {install.packages(p)}

# Set your directory here (do NOT touch anything ABOVE this line)
knitr::opts_knit$set(root.dir = "")
```

#### b) Install Packages

If you do **not** have the necessary packages installed yet, run the chunk below. Otherwise, there is **no need** to run this chunk again.

```{r}
# Install normal packages
norm_pack = c("tidyverse", "BiocManager", "viridis", "RColorBrewer", "cowplot", "gridExtra", "tiff", "kohonen")
for (p in norm_pack) {
  if (!require(p, quietly = TRUE)) {
    install.packages(p)
  }
}

# Install Bioconductor packages
bioc_pack = c("SpatialExperiment", "dittoSeq", "flowCore", "scater", "BiocSingular", "bluster", "ConsensusClusterPlus", "CATALYST")
for (p in bioc_pack) {
  if (!require(p, quietly = TRUE)) {
    BiocManager::install(p)
  }
}
```

#### c) Load in Required Packages

Make sure to run the chunk before **every** analysis session - this loads in the required packages.

```{r}
# Import required packages
library(tidyverse)
library(SpatialExperiment)
library(dittoSeq)
library(viridis)
library(RColorBrewer)
library(flowCore)
library(scater)
library(cowplot)
library(BiocSingular)
library(bluster)
library(ConsensusClusterPlus)
library(gridExtra)
library(tiff)
```

## 1. Importing the Relevant Data

#### a) Create a DataFrame From Your CellProfiler Output

This step combines the `.csv` files in your `5_cellprofiler_output` folder into a single DataFrame, which is saved as `IMCData.rds` in a new `RDSFiles` folder.

**Important:** before this step, make sure to modify `Image.csv` as necessary to include the `DonorID` and `Condition` associated with each image.

```{r}
# Load CSVs
cells = read.csv("5_cellprofiler_output/cell.csv")
panel = read.csv("../raw/panel.csv")
image = read.csv("5_cellprofiler_output/Image.csv")

# Filter rows and columns
image = image %>%
  mutate(Image = str_remove(FileName_FullStack , "_full\\.tiff")) %>%
  select(-FileName_FullStack)
panel = panel %>%
  dplyr::filter(trimws(Target) != "") %>%
  mutate(Metal = Metal.Tag) %>% 
  select("Metal", "Target") %>%
  dplyr::filter(Metal != "Ir191")

# Join image data with cell data
cellsCombined = left_join(cells, image, by = join_by(ImageNumber))

# Define old column names and what to change them to
rename_vec = c(
  "Image" = "Image",
  "ImageNumber" = "ImageID",
  "ObjectNumber" = "CellID",
  "AreaShape_Area" = "Area",
  "AreaShape_Center_X" = "X",
  "AreaShape_Center_Y" = "Y",
  "DonorID" = "DonorID",
  "Condition" = "Condition"
)

# Change names in 'cellsCombined' from old names to new names
names(cellsCombined) = ifelse(names(cellsCombined) %in% names(rename_vec), rename_vec[names(cellsCombined)], names(cellsCombined))

# Name marker columns
markers = panel[,"Target"]
ordered_markers = markers[createSortedVector(length(markers))]
colnames(cellsCombined)[6:(length(markers)+5)] = ordered_markers

# Keep only desired columns
meta = unname(sapply(strsplit(rename_vec, " = "), '[', 1))
keep = c(meta,ordered_markers)
cellsCombined = cellsCombined %>% select(all_of(keep))

# Save DataFrame as a '.rds' file
dir.create("RDSFiles", showWarnings = FALSE)
saveRDS(cellsCombined, "RDSFiles/IMCData.rds")
```

#### b) Creating a SpatialExperiment Object

This step creates a `SpatialExperiment` object called `spe`, which we will be working out of for most of the subsequent analysis below. For more information on the `SpatialExperiment` class, see [this](https://www.bioconductor.org/packages/release/bioc/vignettes/SpatialExperiment/inst/doc/SpatialExperiment.html).

An arcsinh transformation is applied to the raw marker values, followed by min-max scaling to standardise the values so they lie between 0 and 1. The distributions of a chosen marker (eg. CD3) are plotted to help visualise the effect of these steps.

An `Image_uCellID_key.csv` file is also generated in your `analysis` folder that indicates which unique cell IDs (uCellIDs) correspond to which images.

```{r}
# Marker expression, other cellular features and spatial features (co-ordinates) are read and merged into a spatial experiment object
dt = readRDS("RDSFiles/IMCData.rds")

# Split data into marker intensities, metadata and co-ordinates
counts = dt[, ordered_markers]*65535
metadata = dt[, setdiff(meta, c("X","Y"))]
coords = dt[, c("X","Y")]

# Create spatial object
spe = SpatialExperiment(
  assays = list(counts = t(counts)),
  colData = metadata,
  spatialCoords = as.matrix(coords),
  sample_id = as.character(metadata$ImageID)
)

# Change variables to 'factor' type
spe$Image = as.factor(spe$Image)
spe$ImageID = as.factor(spe$ImageID)
spe$DonorID = as.factor(spe$DonorID)

### Assign colour palettes
color_vectors <- list()
# DonorID
donor_ids <- unique(spe$DonorID)
# Create a color vector that repeats  if there are more than 12 unique DonorIDs
donor_colors <- brewer.pal(12, name = "Paired")[as.numeric(donor_ids) %% 12 + 1]
# Set the names of the colors to match the unique DonorIDs
DonorID <- setNames(donor_colors, donor_ids)
color_vectors$DonorID <- DonorID

# ImageID
image_ids <- unique(spe$ImageID)
# Create a color vector that repeats  if there are more than 12 unique ImageIDs
image_colors <- brewer.pal(12, name = "Paired")[as.numeric(image_ids) %% 12 + 1]
# Set the names of the colors to match the unique ImageIDs
ImageID <- setNames(image_colors, image_ids)
color_vectors$ImageID <- ImageID

# Merge colour palettes back into 'spe' object
metadata(spe)$color_vectors <- color_vectors
colnames(spe) = paste0(spe$ImageID, "_", spe$CellID)

# Plot current distribution
suppressMessages(print(dittoRidgePlot(spe, var="CD3", group.by="ImageID", assay="counts", max=10) + ggtitle("CD3 - before transformation")))

# Plot distribution after arcsinh transforming data
assay(spe, "exprs") = asinh(counts(spe))
suppressMessages(print(dittoRidgePlot(spe, var="CD3", group.by="ImageID", assay="exprs", max=10) + ggtitle("CD3 - after arcsinh transformation")))

### Standardise values between 0 and 1 for each image
# Extract the expression matrix and image information
exprs_matrix = assay(spe, "exprs")
images = spe$Image

# Get unique images and channels
unique_images = unique(images)
channels = rownames(exprs_matrix)

# Prepare a matrix to store standardised expressions
base_matrix = matrix(NA, nrow = nrow(exprs_matrix), ncol = ncol(exprs_matrix))
rownames(base_matrix) = channels
colnames(base_matrix) = colnames(exprs_matrix)

# Iterate over each image and channel to standardise
for (image in unique_images) {
    image_indices = which(images == image)
    for (channel in channels) {
        channel_data = exprs_matrix[channel, image_indices]
        # Apply min-max scaling
        min_val = min(channel_data, na.rm = TRUE)
        max_val = max(channel_data, na.rm = TRUE)
        range_val = max_val - min_val
        # Avoid division by zero if all values in channel_data are the same
        if (range_val != 0) {
            norm_data = (channel_data - min_val) / range_val
        } else {
            norm_data = rep(0, length(channel_data))  
        }
        base_matrix[channel, image_indices] <- norm_data
    }
}

# Assign the standardised data back to the assay
assay(spe, "norm_exprs") = base_matrix

# Plot distribution after standardising the data
suppressMessages(print(dittoRidgePlot(spe, var="CD3", group.by="ImageID", assay="norm_exprs", max=1.0) + ggtitle("CD3 - after standardising")))

# Add a universal CellID column
colData(spe)$uCellID = 1:length(spe$CellID) 
uIDKey = as.data.frame(colData(spe))
uIDKey = uIDKey %>%
  group_by(Image) %>%
  dplyr::filter(row_number()==1) %>%
  select(Image, ImageID, uCellID)

# Write a CSV matching ImageIDs with uCellIDs
write.csv(uIDKey, "Image_uCellID_key.csv")
saveRDS(spe, "RDSFiles/spe.rds")
```

## 2. Gating Populations in FlowJo with Help From Mantis

#### a) Export as `.fcs` to Gate in FlowJo

This step generates one `.fcs` file for **each** image in a new `FlowJo` folder, which you can then gate on as usual. There is also an `exports` folder created **within** your `FlowJo` folder for you to export your gated populations to.

```{r}
# Load in 'spe' object
spe = readRDS("RDSFiles/spe.rds")

# Re-extract image data and metadata
image = read.csv("5_cellprofiler_output/image.csv") %>%
  mutate(ImageName = str_remove(FileName_FullStack , "_full\\.tiff")) %>%  
  select(ImageNumber, ImageName) %>%
  dplyr::rename(ImageID = ImageNumber)
metadata = as.data.frame(colData(spe)) %>%
  select(ImageID, uCellID, CellID, Area)

# Multiply by 1000 to match scale of visualisation in flowjo.
assayData = as.data.frame(t(assay(spe, "norm_exprs")))*1000

# Combine metadata and assay data
df = cbind(metadata, as.data.frame(spatialCoords(spe)), assayData)
df$ImageID = as.numeric(df$ImageID)
df = df %>%
  left_join(image, by="ImageID") %>%
  group_by(ImageID) %>%
  mutate(Y = max(Y)-Y)

# Export data as '.fcs' to gate in FlowJo
split_data = split(df, df$ImageName)
dir.create("../FlowJo/exports", showWarnings = FALSE, recursive = TRUE)
lapply(names(split_data), function(name) write_fcs(split_data[[name]], name))
```

#### b) Prepare a `MantisProject` Folder to View Cells in Mantis

You can download Mantis Viewer from [here](https://github.com/CANDELbio/mantis-viewer/releases). It is an application we will use to visualise cells and marker expressions from our IMC images. Mantis Viewer requires a `MantisProject` folder to view images from, which will be generated by the chunk below.

```{r}
# Load in 'spe' object and 'panel.csv' file
spe = readRDS("RDSFiles/spe.rds")
panel = read.csv("../raw/panel.csv")

# Create 'MantisProject' folder
dir.create("../MantisProject", showWarnings = FALSE)

# List TIFFs and CSVs in the '1c_full_images' folder
tiffs = list.files("1c_full_images", pattern = "\\.tiff$")
csvs = list.files("1c_full_images", pattern = "\\.csv$")

# Generate individual channel images as TIFFs and copy them to the MantisProject folder
for (x in seq_along(tiffs)) {
  # Extract the name of the current image from the filename
  cur_img = gsub(".{10}$", "", tiffs[x])
  # Create a new folder for the current image
  dir.create(paste0("../MantisProject/", cur_img), showWarnings = FALSE)
  # Read TIFF and CSV associated with the current image
  cur_tiff = readTIFF(paste0("1c_full_images/", tiffs[x]), all=TRUE)
  cur_csv = read.csv(paste0("1c_full_images/", csvs[x]), header=FALSE)$V1
  # Save each individual channel in the TIFF as a separate image
  for (channel in seq_along(cur_tiff)) {
    metal_tag = cur_csv[channel]
    marker = panel$Target[panel$Metal.Tag == metal_tag]
    filename = paste0("../MantisProject/", cur_img, "/", marker, ".tiff")
    mat = cur_tiff[[channel]]*65535
    writeTIFF((mat-min(mat))/(max(mat)-min(mat)), filename)
  }
}

# Copy segmentation masks to 'MantisProject' folder
seg_list = list.files("3a_segmentation_masks", pattern = "\\.tif$")
for (cur_dir in seg_list) {
  cur_img = gsub(".{23}$", "", cur_dir)
  new_dir = paste0("../MantisProject/", cur_img, "/SegmentationFile.tif")
  file.copy(paste0("3a_segmentation_masks/", cur_dir), new_dir)
}

# Extract the full assay data (markers) and transpose it
markers = rownames(spe)
marker_data = as.data.frame(t(assay(spe, "norm_exprs")))

# Add metadata as columns to marker_data
metadata = as.data.frame(colData(spe))
marker_data = cbind(metadata, marker_data)

for (img in unique(colData(spe)$Image)) {
  # Filter the combined data to keep only rows corresponding to images in Mantis
  filtered_data = marker_data[marker_data$Image %in% c(img), ]
  # Select only relevant columns
  selected_columns = c("Image", "CellID", markers)
  final_data = filtered_data[, selected_columns]
  # Check if all entries in the 'Image' column are the same (only one image)
  if (length(unique(final_data$Image)) == 1) {
      final_data$Image <- NULL
  }
  # Rename the remaining columns if necessary
  colnames(final_data)[colnames(final_data) %in% c("CellID")] = c("Segment ID")
  # Save the final filtered and selected data to a CSV file
  write.csv(final_data, paste0("../MantisProject/", img, "/SegmentFeatures.csv"), row.names = FALSE)
}
```

#### c) Gate in FlowJo with Reference to Mantis Viewer

Use Mantis Viewer to assist your gating in FlowJo, by visually checking your threshold values for each marker to see that they are accurate.

#### d) Import FlowJo Clusters Into Mantis Viewer For Verifying

To check that you are happy with your gating in FlowJo, you can import your populations into Mantis Viewer and view them. This step generates a `FlowJo_CellTypes.csv` file in your `MantisProject` folder, which you can **import** and **view** as a new **population** in Mantis Viewer.

If you wish to change your gating a bit, simply create new gates in FlowJo and re-export your populations as `.csv` files to your `FlowJo/exports` folder. Then, **re-run** the chunk below to **overwrite** the existing `FlowJo_CellTypes.csv` file so you can view your new populations.

```{r}
# Load in 'spe' object
spe = readRDS("RDSFiles/spe.rds")

# List exported CSVs from FlowJo
csvs = list.files(path = "../FlowJo/exports", pattern = "*.csv", full.names = TRUE)

# Combine CSVs from FlowJo and metadata into one DataFrame
csvs = lapply(csvs, add_celltype)
flowjo_df = bind_rows(csvs) %>%
  select(uCellID, celltype_flowjo)
flowjo_df$celltype_flowjo = as.factor(flowjo_df$celltype_flowjo)
metadata = as.data.frame(colData(spe))
flowjo_df = left_join(metadata, flowjo_df, by = c("uCellID"))

# Remove NAs (cells without an assigned population from FlowJo)
celltype_info = flowjo_df[, c("Image", "CellID", "celltype_flowjo")] %>%
  na.omit()

# Export FlowJo populations for viewing in Mantis Viewer 
celltype_by_image = split(celltype_info, celltype_info$Image)
celltypes = lapply(names(celltype_by_image), extract_celltypes)
celltype_df = bind_rows(celltypes)
write.table(celltype_df, "../MantisProject/FlowJo_CellTypes.csv", sep=",",  col.names=FALSE, row.names=FALSE)

# Save FlowJo populations as a '.rds' file
saveRDS(celltype_df, "RDSFiles/flowjo_celltypes.rds")
```
